
\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos,highlightlines={ 3,4 }
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
This is a test

\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos,highlightlines={ 3,4 }
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
This is a test

\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos,highlightlines={ 4 }
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
Here, we've copied the initial parameters that we inputted by hand, knowing what the hartree-fock state is. 

\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos,highlightlines={ 13 }
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
          

    \end{minted}
At this stage, we have got the first lamda- the first non-zero $t$ value. We evaluate $H(t)$.
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos,highlightlines={ 12,14 }
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
           


    \end{minted}
Perhaps these need to be swapped

\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}

    \end{minted}
Nope, still no good. 

\end{frame}



\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}Testing this
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}Testing this
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}Testing this
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}Testing this
\end{frame}

\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos
        ]
        {python}
class My_AAVQE():
    def alternative_run(self):
        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]            
        optimal_thetas = self.initial_parameters.copy()
        instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
        initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
        energies_aavqe = [instantaneous_expectation_value]
        energies_exact = [initial_ground_state]        
        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')
        for lamda in lambdas:
            print('\n')
            print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
            hamiltonian = self.get_instantaneous_hamiltonian(lamda)
            minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
            optimal_thetas = minimization_object.x
            self.offset=0
            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
            energies_aavqe.append(inst_exp_value)
            energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
            #print(f'and the hamiltonian right now is {hamiltonian} ')           
            print(f'and the instantaneous expectation values is {inst_exp_value}') 
            print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
#Question now is how will we compute the true expectation value? Will we do it from the Hamiltonian that was created? 
        plt.plot(energies_aavqe,label='aavqe energy')
        plt.plot(energies_exact,label='true energy')
        plt.legend()
        plt.xlabel('time')
        plt.ylabel('energy (Ha)')
        plt.title(f'{self.string_initial_hamiltonian} and {self.string_final_hamiltonian}')
        plt.show()
        return energies_aavqe


    \end{minted}Testing this
\end{frame}
