
\begin{frame}[fragile]{}
    \begin{minted}
        [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=myblue!20,
        fontsize=\tiny,
        linenos,highlightlines={2,3}
        ]
        {python}
        class My_AAVQE():
          def alternative_run(self):        
            lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]
            optimal_thetas = self.initial_parameters.copy()
            instantaneous_expectation_value=self.get_expectation_value(optimal_thetas,self.initial_hamiltonian)
            initial_ground_state=self.minimum_eigenvalue(self.initial_hamiltonian)
            energies_aavqe = [instantaneous_expectation_value]
            energies_exact = [initial_ground_state]
            print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')                
            for lamda in lambdas:
                print('\n')
                print(f'We are working on {lamda} where the current optimal point is {optimal_thetas}')
                hamiltonian = self.get_instantaneous_hamiltonian(lamda)    
                minimization_object = optimize.minimize(self.get_expectation_value, x0=optimal_thetas, args=(hamiltonian), method='SLSQP')
                optimal_thetas = minimization_object.x
                self.offset=0
                
                inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) - lamda*self.offset
                energies_aavqe.append(inst_exp_value)
                energies_exact.append(self.minimum_eigenvalue(hamiltonian) - lamda*self.offset)
                #print(f'and the hamiltonian right now is {hamiltonian} ')
                
                print(f'and the instantaneous expectation values is {inst_exp_value}') 
                print(f'and the true expectation value is {self.minimum_eigenvalue(hamiltonian) - lamda*self.offset}')
            return energies_aavqe
    \end{minted}
\end{frame}
